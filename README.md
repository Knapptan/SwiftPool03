### Проект: утилиты для создания игр

## Задания:

### Задание 1. Мир дикого запада
Требуется описать класс, моделирующий револьвер. 
В данном задании это типизированный класс. 
Обойма револьвера содержит элемент в соответствии с объявленным типом. 
Например, RevolverMoonClip<Int> будет хранить элементы типа `Int`.

- Обойма револьвера представляет собой массив из 6 элементов. Если слот пустой, то там должен храниться `nil`.
- Ты можешь добавить один элемент в ближайший свободный слот методом `add()`. При успешном добавлении возвращается true, иначе - false.
- Возможно добавление путем списка элементов. Функция принимает другую коллекцию, как ресурс, из которого добавляются все элементы в обойму. Если элементов в коллекции недостаточно, то заполняется объект револьвера настолько, насколько возможно. Если список пустой, метод возвращает false.
- Класс имеет свойство `pointer`. С его помощью ты сможешь получать текущий элемент на курке. Таковым является элемент в обойме с индексом 0.
- Ты можешь удалять элементы одним за одним при помощи метода стрельбы `shoot()`, который возвращает удаленный элемент. Удаление начинается с элемента `pointer`.
- Ты можешь вызывать `unloadAll()` для всех элементов разом или `unload(index)` для извлечения одного. Функция возвращает извлеченный элемент либо список всех элементов.
- Ты можешь прокрутить обойму методом `scroll()`, меняя позицию pointer на случайный элемент. Последовательность элементов между собой должна сохраниться, при этом элемент на курке должен поменяться.
- Добавь метод getSize(), который возвращает количество элементов в револьвере.
- Создай функцию расширения `toStringDescription()` для класса, которая будет представлять информацию об объекте класса и его элементах в виде `String`. Информация об элементах записывается, начиная с позиции элемента на курке (pointer).
- У класса должен корректно работать оператор сравнения `==`. Переопредели его при помощи протокола `Equatable`. Объекты класса эквивалентны, если имеют одинаковое сочетание элементов, начиная с любой позиции, включая nil. Пример сравнения представлен ниже. 
- Сделай для класса метод `subscript(index: Int`). Он будет возвращать для любого револьвера при обращении по индексу элемент, который находится на данной позиции в обойме. Если индекс больше чем число элементов в обойме, то происходит ошибка.

**Результат:** напиши программу, которая показывает, как работает класс `RevolverMoonClip`, и запусти ее
1. Создай объект револьвера, заполнив его при помощи конструктора максимальным количеством элементов. Выведи в консоль описание класса типа `RevolverMoonClip<Type>`, содержимое обоймы, начиная с `pointer` и сам `pointer`.
2. Получи первый и последний элемент в обойме при помощи `subscript`, вызвав индексы соответствующих элементов.
3. Вызови метод `scroll` и выведи объект консоль. Результат должен начинаться с другого элемента (но он может быть равным по значению). Порядок между элементами должен сохраняться.
4. Удали 4 элемента один за другим. Напечатай объект класса и сравни с предыдущим выводом. Измененная обойма должна начинаться с 5-ого элемента, за ним должен идти тот же элемент, что и до этого, затем 4 значения `nil`.
5. Создай коллекцию из 8 элементов того же типа, что и дженерик созданного объекта. Добавь эту коллекцию в револьвер и выведи сравнение старой и новой коллекции в револьвере. Обойма должна заполняться полностью первыми 4 элементами из коллекции. `pointer` устанавливается при каждом добавлении на заполненный элемент обоймы.
6. Вытащи все элементы класса `unloadAll`. Напечатай размер вытащенного списка и размер объекта (должно быть 6 и 0) 
7. Добавь 4 элемента `supply` в коллекцию объекта класса. Размер обоймы револьвера должен стать 4.
8. Создай новый объект с теми же элементами, как в полученном выше списке. Также необходимо сделать предварительный scroll. Далее сопоставь при помощи оператора `==` эквивалентны ли эти объекты. Результат операции должен быть true.

_Пример вывода программы_
```
1. Adding elements
Structure: RevolverMoonClip<Int> 
Objects: [3, 54, 7, 2, 56, 4]
Pointer: 3

2. Subscript
3, 4

3. Scroll
Structure: RevolverMoonClip<Int> 
Objects: [7, 2, 56, 4, 3, 54]
Pointer: 7

4. Deletion
Structure: RevolverMoonClip<Int> 
Objects: [3, 54, nil, nil, nil, nil]
Pointer: 3

5. Supply collection
Before: 
Supply collection: [4, 6, 3, 22, 77, 43, 76, 5]

Structure: RevolverMoonClip<Int> 
Objects: [3, 54, nil, nil, nil, nil]
Pointer: 3

After add operation performed:
Structure: RevolverMoonClip<Int> 
Objects: [22, 3, 6, 4, 3, 54]
Pointer: 22

6. Extraction
The extracted list: [22, 54, 6, 4, 3, 54]
size: 6

Structure: RevolverMoonClip<Int> 
Objects: [nil, nil, nil, nil, nil, nil]
Pointer: nil
size: 0

7. Supply collection 2
Before:
Supply collection: [77, 43, 76, 5]

Structure: RevolverMoonClip<Int> 
Objects: [nil, nil, nil, nil, nil, nil]
Pointer: nil

After add operation performed:
Structure: RevolverMoonClip<Int> 
Objects: [5, 76, 43, 77, nil, nil]
Pointer: 5

8. Equals
Structure: RevolverMoonClip<Int> 
Objects: [nil, 5, 76, 43, 77, nil]
Pointer: nil

Structure: RevolverMoonClip<Int> 
Objects: [nil, nil, 5, 76, 43, 77]
Pointer: nil

Result: equals
```

### Задание 2. Патроны
Требуется описать классы для работы с патронами в револьвере.

**Патрон:**
- Создай класс для патрона (Patron)
- Также здесь нужно добавить поля для описания патрона (холостой или заряженный)
- Для уникальности патронов можешь использовать класс `UUID`
- Патрон должен содержать свойство калибра (например - 22, 38, 45)
- Класс должен иметь свой метод `shoot()` с выводом «Bang» и информации о калибре

**Обновление содержания класса револьвера:**
- Добавь свойство калибра для револьвера
- Сделай так, что револьвер работал только с типом `Patron`. Ты не можешь класть патроны разных калибров в одну обойму. Убери типизацию из класса.
- При вызове `shoot()` соответствующий вызов должен происходит и у патронов. Однако, если патрон холостой, то shoot у его класса вызывать не нужно. 
- Если происходит выстрел при пустой ячейке, программа выводит «Click»

**Представление соответствующей логики для классов револьвера и патронов:**
  - Патрон может быть только в одной обойме револьверов. Если ты пытаешься добавить патрон, который уже есть в другой обойме, метод револьвера `add` должен возвращать false. Также, если ты добавляешь коллекцию патронов, то подобный патрон должен быть проигнорирован, а остальные добавлены. Аналогично для патронов, не совпадающих калибром с револьвером.
  - Каждый патрон может быть использован для заряженного выстрела лишь раз. Если патрон холостой, он выпадет из револьвера, но выстрел не произойдет. Револьвер не должен вызывать метод стрельбы у патрона, но печатает «Click», аналогично выстрелу из пустой ячейки.

**Проверка результата:** для проверки создай программу, которая делает следующее. 
- Проверь, что заряженные патроны стреляют, а холостые нет
- Попробуй добавить патрон в разные револьверы. При первичном добавлении вернется true, вторичном - false. Предварительно создай 2 пустых револьвера.
- Попробуй добавить патрон в две разные коллекции. И попробуй добавить эти коллекции в два разных револьвера. Предварительно создай 2 пустых револьвера.

_Пример вывода программы_
```
1. Shoot or damp
Structure: RevolverMoonClip 32 caliber
Objects: [Patron(id1, charged, 32), Patron(id2, damp, 32), nil, nil, nil, nil]
Pointer: Patron(id1, charged, 32)

Shoot # call shoot()
Bang 32

Structure: RevolverMoonClip 32 caliber
Objects: [Patron(id2, damdp, 32), nil, nil, nil, nil, nil]
Pointer: Patron(id2, damp, 32)

Shoot 
Click
Objects: [nil, nil, nil, nil, nil, nil]
Pointer: nil

2. Unique Patron
Patron(id, charged, 32)

Revolver1: [nil, nil, nil, nil, nil, nil]
Revolver2: [nil, nil, nil, nil, nil, nil]

Add1 # call add()
Revolver1: [Patron(id, charged, 32), nil, nil, nil, nil, nil]
Revolver2: [nil, nil, nil, nil, nil, nil]

Add2
Revolver1: [Patron(id, charged, 32), nil, nil, nil, nil, nil]
Revolver2: [nil, nil, nil, nil, nil, nil]

3. Unique Patron in collection
Revolver1: [nil, nil, nil, nil, nil, nil]
Revolver2: [nil, nil, nil, nil, nil, nil]

[Patron(id, charged, 32), Patron(id1, charged, 32), Patron(id2, charged, 32)]
[Patron(id, charged, 32), Patron(id3, charged, 32), Patron(id4, charged, 32)]

Add1 # call add for 1 st collection

Add2 
Revolver1: [Patron(id, charged, 32), Patron(id1, charged, 32), Patron(id2, charged, 32), nil, nil, nil]
Revolver2: [Patron(id3, charged, 32), Patron(id4, charged, 32), nil, nil, nil, nil]
```

### Задание 3. Профиль игрока

В данном задании требуется создать объект для профиля игрока и реализовать паттерн `делегат` в виде присваивания объекта сервера классу игрока для поиска противника.

**Профиль игрока:**
Класс `Profile` должен содержать:
- ID при помощи `UUID`
- Никнейм
- Возраст
- Имя
- Револьвер
- Дата создания профиля в виде `String`
- Статус (`IN_PLAY` - в игре, `SEARCH` - в поиске, `IDLE` - в ожидании, `OFFLINE` - не в сети)
- Ссылка, которая будет формировать при помощи переменной `lazy var` по примеру `http://gameserver.com/${id}-${nickname}`

**Игровой сервер**
Класс `Server` будет описывать логику взаимодействия между игроками. Объект должен содержать следующее:
- Адрес сервера
- Список игроков на сервере (список `Profile`)

**Делегат сервера в профиле**
При построении архитектуры в IOS приложении не редким является использование паттерна `Делегат` для вызова части логики. Реализуем этот паттерн на примере вызова игроком поиска соперника.
Создай протокол `PlayerAction`, который опишет возможные действия игрока при взаимодействии с сервером. В нашем случае там будет описана функция `findOpponent`. 
Класс `Server` должен унаследовать протокол и реализовать эту функцию. Функция возвращает профиль найденного игрока.
Делегат сервера добавь в виде переменной `playerActionDelegate` класса `PlayerAction`, который будет вызывать запрос поиска противника.

**Проверка результата:** создай несколько объектов профилей с разным статусом и помести их на сервер. Создай свой профиль, который будет в режиме ожидания. Помести его также на сервер. 
Далее программа должна вызвать поиска оппонента и поменять статус игрока на `SEARCH`. Функция должна вернуть оппонента противника, с новым статусом `IN_PLAY` и поменять статус в профиле игрока.

_Пример вывода программы_
```
SearcherProfile:
Profile("coolpicker", IDLE)

ServerProfiles:
[Profile("super3228", IDLE), Profile("lrdxg", SEARCH), Profile("kmaw", IN_PLAY), Profile("aveelyr", SEARCH), Profile("coolpicker", IDLE)]

Start Search
SearcherProfile:
Profile("coolpicker", SEARCH)
ServerProfiles:
[Profile("super3228", IDLE), Profile("lrdxg", SEARCH), Profile("kmaw", IN_PLAY), Profile("aveelyr", SEARCH),  Profile("coolpicker", SEARCH)]

Result Search
SearcherProfile:
Profile("coolpicker", SEARCH)
Opponent:
Profile("lrdxg", SEARCH)
ServerProfiles:
[Profile("super3228", IDLE), Profile("lordyxD", IN_PLAY), Profile("kmaw", IN_PLAY), Profile("aveelyr", SEARCH),  Profile("coolpicker", IN_PLAY)]
```